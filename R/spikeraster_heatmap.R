#' Spike Rasters and Heatmaps
#'
#' Create raster plots and heatmaps
#'
#' @param object Object of class MEASpikeR generated by the \code{dataset_filtering} function
#' @param filt.data.path Path to the "MEA_DATA2ANALYZE.Rdat" file generated
#' by the \code{dataset_filtering} function.
#' @param working_directory Character specifying the working directory where we want to save the output pdf file
#' @param scale Character specifying the scale ("free"/"fixed")(by default "free")
#' @param end_record_color Character specifying the color of vertical bar at the end of recording (by default "red") for the raster plots
#' @param spike_col Character specifying the color of the spikes of the raster plots (by default "black")
#' @param add.burst Boolean, if TRUE, it displays bursts in color in the raster plot
#' @param burst.detection.method Character specifying the choice of
#' the burst detection method ("MI" or "Chen")(by default "MI")
#' @param max_ISI_start_burst Parameter settings for burst detection (for MI) (by default 170)
#' @param max_ISI_end_burst Parameter settings for burst detection (for MI) (by default 300)
#' @param min_IBI Parameter settings for burst detection (for MI) (by default 50)
#' @param min_spike_in_burst Parameter settings for burst detection (for MI) (by default 5)
#' @param min_burst_duration Parameter settings for burst detection (for MI) (by default 50)
#' @param mypal Character specifying the color palette for the heatmap (by default "viridis2")
#' @param col.cell.border Character specifying the color delimiting the cells in the heatmap (by default "gray85")
#'
#' @return A PDF file displaying raster plots and heatmaps located in the working directory
#' @export
#' @author Fran√ßois-Xavier Lejeune, Gaspard Martet, Carine Dalle, Stephen Whitmarsh
#' @references  Dalle C., Martet G., Lejeune FX., Rebola N., Kaddouri Y., Whitmarsh S.(2023). **_MEASpikeR_: a new package
#' for spike analysis and visualization of _in vitro_ MEA data**.
#'
#' @examples \dontrun{
#' out.MEA <- MEASpikeR::dataset_filtering(data.path = "C:/Users/prenom.nom/Documents/data",
#' guideline_name_file = "MEA_Spikes_ANA_R_guideline",
#' save.rDATA = TRUE)
#'
#' # if you want to work with the MEASpikeR object
#' MEASpikeR::spikeraster_heatmap(
#' object = out.MEA,
#' working_directory = "C:/Users/prenom.nom/Documents"
#' )
#'
#' # if you want to work with the saved Rdat file
#' MEASpikeR::spikeraster_heatmap(
#' filt.data.path = "C:/Users/prenom.nom/Documents/data/MEA_DATA2ANALYZE.Rdat",
#' working_directory = "C:/Users/prenom.nom/Documents"
#' )}
spikeraster_heatmap <- function(
    object = NA,
    filt.data.path = NA,
    working_directory = NA,
    scale = "free",
    end_record_color = "red",
    spike_col = "black",
    add.burst = TRUE,
    burst.detection.method = "MI",
    max_ISI_start_burst = 170,
    max_ISI_end_burst = 300,
    min_IBI = 50,
    min_spike_in_burst = 5,
    min_burst_duration = 50,
    mypal = "viridis2",
    col.cell.border = "gray85"
) {

  if ( all(!(is.na(object))) & class(object) == "MEASpikeR") {

    attach(object)

  } else {

    if (!(is.na(filt.data.path))) {

      load(filt.data.path)

    } else {

      stop("arguments object and filt.data.path are missing, with no default.")

    } }
  # working directory

  if(!is.na(working_directory)) {setwd(working_directory)}

  else {stop("argument 'working_directory' is missing with no default")}

  mypal <- MEASpikeR:::select_palette(mypal)

  # Find the max rate (Hz) and max total of peaks (# spikes) over all the recordings (files)
  # These values will be required to pre-define the legend limits of the plots

  #-- Initialize both values "max_rate" and "max_tot.spikes" to zero --#

  max_tot.spikes <- 0

  #-- Loop over the files indicated by Filename in guideline excel file --#

  for (i in 1:nb.condition) {

    dat <- get(as.character(info.cond$Filename[i]))
    if (length(dat$channel) > 1) max_tot.spikes <- max(max_tot.spikes, max(table(dat$channel)))

  } # end_for

  # max_tot.spikes

  #----------#

  #-- Main --#

  #----------#

  # Initialize list of plots

  # loop over the conditions of the guideline file

  plot_list <- list()

  for (j in 1:nb.condition) {

    cat("### condition =", j, "\n")

    filename_spike <- guideline$Filename_spike[j]

    # titre heat map

    lab.exp <- paste0(guideline[j, "ConditionNumber"], " - ",
                      guideline[j, "ExperimentalGroup"], "_", guideline[j, "ExperimentalCondition"] )

    #-- Cut file names at .modat --#

    shortname <- unlist(strsplit(filename_spike, split = ".modat"))[1] # to display in the pdf output file

    start_TW <- guideline$TimeLimitStart[j]
    end_TW <- guideline$TimeLimitEnd[j]
    true_end <- info.cond$true_end[j]
    time.range <- end_TW-start_TW

    #-- If empty file --#

    if ( info.cond$empty.file[j] ) {

      p1 <- MEASpikeR:::draw_void_rasterplot(shortname, start_TW, end_TW)
      p2 <- MEASpikeR:::draw_void_heatmap(lab.exp, mypal, col.cell.border)

      plot_list[[2*(j-1)+1]] <- p1
      plot_list[[2*(j-1)+2]] <- p2

    } else { # If not empty file

      #-- Import data --#

      dat <- get(as.character(info.cond$Filename[j]))
      record_duration <- info.cond$record_duration[j]

      if (nrow(dat) > 0) {

        #-- Additional time exclusion --#

        TeX <- 0
        TeX_limits <- NULL

        if ( !(is.na(info.cond$intTeX[j])) ) {

          TeX_limits <- do.call("rbind",
                                strsplit(unlist(strsplit(as.character(info.cond$intTeX[j]), split = ",")), "-"))
          TeX_limits <- matrix(apply(TeX_limits, 2, as.numeric), ncol = 2)
          colnames(TeX_limits) <- c("start", "end")

        }

        #-- analyzed time --#

        analyzed.time <- info.cond$time.analyzed[j]

      }

      if (nrow(dat) > 0 & add.burst == TRUE) { # if_add.burst

        dat <- dat[ order(dat$channel, dat$within_session_time_ms), ]

        spike.order <- unlist( tapply(dat$within_session_time_ms, list(dat$channel), rank) )
        isi.ms <- unlist( tapply(dat$within_session_time_ms, list(dat$channel), MEASpikeR:::diff_isi) )
        dat <- data.frame(dat, spike.order, isi.ms)

        # Burst detection following Chen or MI procedure

        if( burst.detection.method == "MI" ) {

          ls.burst <- lapply(unique(dat$channel),
                             function(i) {MEASpikeR:::detect_burst_mi(dat$isi.ms[dat$channel == i],
                                                         min_spike_in_burst,
                                                         max_ISI_start_burst,
                                                         max_ISI_end_burst,
                                                         min_IBI,
                                                         min_burst_duration)})

        } # end_if_MI

        if( burst.detection.method == "chen") {

          ls.burst <- lapply(unique(dat$channel),
                             function(i) MEASpikeR:::detect_burst_chen(dat$isi.ms[dat$channel == i], min_spike_in_burst))

        } # end_if_chen

        # names(ls.burst) <- unique(dat$channel)

        dat <- data.frame(dat, burst = as.vector(unlist(ls.burst)))

      } # end_if_add.burst

      #-- Use max_rate and max_tot.spikes values if scale is "fixed" (i.e. same scale for all plots) --#

      if ( !(scale %in% c("free", "fixed")) ) scale <- "free"

      if (scale == "free") {

        midpoint.nb <- 0
        limits.nb <- NULL

      } else {

        midpoint.nb <- max_tot.spikes/2
        limits.nb <- c(0, max_tot.spikes)

      }

      if (nrow(dat) == 0) {

        #-- Plot 1 "Raster plot --#

        p1 <- MEASpikeR:::draw_void_rasterplot(shortname, start_TW, end_TW)

        #-- Plot 2 "Number total of peaks per channel" matrix plot --#

        p2 <- MEASpikeR:::draw_void_heatmap(lab.exp, mypal, col.cell.border)

        plot_list[[2*(j-1)+1]] <- p1
        plot_list[[2*(j-1)+2]] <- p2

      } else {

        #-- Start, end and step values for time display --#

        if (add.burst == FALSE) { dat$burst <- NA }

        lM <- data.frame(channel = dat$channel,
                         time.s = round(dat$within_session_time_ms/1000, 1),
                         burst = dat$burst,
                         count = 1
        )

        #-- Matrix 8 x 8 with total spikes for the "total number of spikes" matrix plot --#

        dat$channel <- factor(dat$channel, levels = 1:64)

        mM <- matrix(table(dat$channel), byrow = TRUE, nrow = 8, ncol = 8)
        colnames(mM) <- paste0("col", 1:8)
        mM <- reshape2::melt(mM)
        colnames(mM) <- c("row", "col", "value")
        mM$row <- factor(mM$row, levels = 8:1)

        #-- Plot 1 = "Rate firing" matrix plot --#

        lM$burst <- factor(ifelse( !(is.na(lM$burst)), "y", "n"))

        step <- 100
        if (time.range <= 50) step <- 5
        if (time.range > 50 & time.range <= 100) step <- 10
        if (time.range > 100 & time.range <= 200) step <- 25
        if (time.range > 200 & time.range <= 600) step <- 50

        p1 <-
          ggplot2::ggplot(lM, ggplot2::aes(x = time.s, y = channel, fill = burst)) +
          ggplot2::geom_tile(show.legend = FALSE, width = (time.range*0.2)/180, height = 1) +
          ggplot2::labs(x = "Time [s]", y = "# Electrode", title = shortname) +
          ggplot2::theme_minimal() +
          ggplot2::scale_x_continuous(
            breaks = seq(start_TW, end_TW, step), expand = c(0, 0), limits = c(start_TW-1, end_TW+1)) +
          ggplot2::scale_y_continuous(
            breaks = seq(1, 64, 1), expand = c(0, 0), trans = "reverse", limits = c(64.5, 0.5) ) +
          ggplot2::theme(
            plot.title = ggplot2::element_text(hjust = 0.5, size = 10),
            axis.text.x = ggplot2::element_text(size = 9, angle = 0, vjust = 0.3, color = "gray5"),
            axis.text.y = ggplot2::element_text(size = 3, color = "gray5"),
            axis.title = ggplot2::element_text(size = 10, angle = 0, vjust = 0.3, color = "black"),
            legend.text = ggplot2::element_text(size = 7),
            panel.grid.major  = ggplot2::element_blank(),
            panel.grid.minor = ggplot2::element_blank(),
            panel.background = ggplot2::element_blank(),
            axis.line.x = ggplot2::element_line(colour = "black", size = .2),
            axis.ticks.x =  ggplot2::element_line(colour = "gray5", size = .2)
          ) +
          ggplot2::scale_fill_manual(values = c(spike_col, "red"))

        if( !is.null(TeX_limits) ) {

          TeX_limits <- as.data.frame(TeX_limits)

          for( k in 1:nrow(TeX_limits) ){

            p1 <- p1 + ggplot2::geom_vline(xintercept = TeX_limits$start[k]+.1,
                                  color = end_record_color, linewidth = .3, linetype = "dashed") +
              ggplot2::geom_vline(xintercept = TeX_limits$end[k]-.1,
                         color = end_record_color, linewidth = .3, linetype = "dashed")
          }

        }

        if (true_end < end_TW)  p1 <- p1 +
          ggplot2::geom_vline(xintercept = true_end, color = end_record_color, linewidth = .5)

        #-- Plot 2 = "Number total of peaks per channel" matrix plot --#

        p2 <- ggplot2::ggplot(mM, ggplot2::aes(x = col, y = row)) +
          ggplot2::geom_tile(ggplot2::aes(fill = value), color = col.cell.border) +
          ggplot2::labs(y = "row #", title = lab.exp) +
          ggplot2::theme_minimal() +
          ggplot2::scale_x_discrete( expand = c(0, 0) ) +
          ggplot2::scale_y_discrete( expand = c(0, 0) ) +
          ggplot2::theme(
            plot.title = ggplot2::element_text(hjust = 0.5, size = 10),
            axis.text.x = ggplot2::element_blank(),
            axis.text.y = ggplot2::element_text(size = 9, color = "gray5", margin = ggplot2::margin(0,5,0,0)),
            axis.title.x = ggplot2::element_blank(),
            axis.title.y = ggplot2::element_text(size = 10, angle = 0, vjust = 1, color = "black"),
            axis.ticks.length = ggplot2::unit(0, "cm"),
            legend.text = ggplot2::element_text(size = 7),
            legend.title = ggplot2::element_text(angle = 90, hjust = .5, size = 9)
          ) +
          ggplot2::labs(fill = "# spikes")

        if (scale == "free") p2 <- p2 + ggplot2::scale_fill_gradientn(colors = mypal)

        if (scale == "fixed") p2 <- p2 + ggplot2::scale_fill_gradient2(
          low = mypal[1],
          mid = mypal[length(mypal)/2],
          high = mypal[length(mypal)], # colors in the scale
          midpoint = midpoint.nb,
          limits = limits.nb )

        p2 <- p2 + ggplot2::guides(fill = ggplot2::guide_colourbar(title.position = "right"))

        plot_list[[2*(j-1)+1]] <- p1
        plot_list[[2*(j-1)+2]] <- p2

      }

    } # end_not_empty_file

  } # end_for

  #-----------------------------------------------------#

  #-- Save all plots in a pdf file (8 plots per page) --#

  #-----------------------------------------------------#

  glist <- lapply(plot_list, ggplotGrob)

  # Use width = 210, height = 297, units = "mm" for A4 size document

  info <- guideline$InformationFolderName[1]

  output.file <- ifelse( !(is.na(info)),
                         paste0("SpikeRasterPlot_HeatMap_Scale_", scale, "_", Sys.time(), "s_", info),
                         paste0("SpikeRasterPlot_HeatMap_Scale_", scale, "_", Sys.time(), "s") )

  if(MinFR > 0){ output.file <- paste0(output.file, "_MinFR", MinFR) }

  output.file <- paste0(output.file, ".pdf")

  output.file <- gsub(" ", "_", output.file)
  ix <- unlist(gregexpr("\\:", output.file))
  substr(output.file, ix[1], ix[1]) <- "h"
  substr(output.file, ix[2], ix[2]) <- "m"

  ggplot2::ggsave(output.file,
         gridExtra::marrangeGrob(glist, nrow = 4, ncol = 2, widths = c(1,1),
                      layout_matrix = matrix(1:8, 4, 2, TRUE),
                      bottom = quote(grid::textGrob(paste("\n", "page", g, "of", npages, "\n"),
                                                    x = .5, hjust = .5)),
                      top = paste("\n", output.file, "\n")),
         width = 210, height = 297, units = "mm")

} # FUNCTION END_MEA_3_SPIKERASTER_HEATMAP
