#' Burst analysis using Chen or MI methods
#'
#' @param object Object of class MEASpikeR generated by the \code{dataset_filtering} function
#' @param filt.data.path Path to the ".Rdat" file generated
#' by the \code{dataset_filtering} function
#' @param output_directory Character specifying the output directory where we want to save the output excel file
#' @param burst.detection.method Character specifying the choice of the burst
#' detection method ("MI" or "chen") (by default "MI")
#' @param max_ISI_start_burst Number, parameter setting for burst detection (by default 170)
#' @param max_ISI_end_burst Number, parameter setting for burst detection (by default 300)
#' @param min_IBI Number, parameter setting for burst detection (by default 50)
#' @param min_spike_in_burst Number, parameter setting for burst detection (by default 5)
#' @param min_burst_duration Number, parameter setting for burst detection (by default 50)
#'
#' @return An excel file with burst analysis located in the output directory
#' specified in the \code{output_directory} argument
#' @export
#' @author Fran√ßois-Xavier Lejeune, Gaspard Martet, Carine Dalle
#' @references  Dalle C., Martet G., Kaddouri Y., Rebola N., Whitmarsh S., Lejeune FX.(2023). **_MEASpikeR_: a new package
#' for spike analysis and visualization of _in vitro_ MEA data**.
#'
#' @examples \dontrun{
#' out.MEA <- MEASpikeR::dataset_filtering(data.path = "C:/Users/prenom.nom/Documents/data",
#' guideline_name_file = "MEA_Spikes_ANA_R_guideline",
#' save.rDATA = TRUE)
#'
#' # if you want to work with the MEASpikeR object
#' MEASpikeR::burst_detection(
#' object = out.MEA,
#' output_directory = "C:/Users/prenom.nom/Documents"
#' )
#'
#' # if you want to work with the saved Rdat file
#' MEASpikeR::burst_detection(
#' filt.data.path = "C:/Users/prenom.nom/Documents/data/MEA_DATAFILTERED.Rdat",
#' output_directory = "C:/Users/prenom.nom/Documents"
#' )
#' }
burst_detection <- function(
    object = NA,
    filt.data.path = NA,
    output_directory = NA,
    burst.detection.method = "MI",
    max_ISI_start_burst = 170,
    max_ISI_end_burst = 300,
    min_IBI = 50,
    min_spike_in_burst = 5,
    min_burst_duration = 50
) {

  burst.info <- NULL

  if ( all(!(is.na(object))) & class(object) == "MEASpikeR") {

    attach(object)

  } else {

    if (!(is.na(filt.data.path))) {

      load(filt.data.path)

    } else {

      stop("arguments object and filt.data.path are missing, with no default.")

    } }

  # working directory

  if(!is.na(output_directory)) {setwd(output_directory)}

  else {stop("argument 'output_directory' is missing with no default")}

  # loop over the conditions of the guideline file

  for (j in 1:nb.condition) {

    cat("### condition =", j, "\n")

    new.burst.info <- NULL

    #-- Import filtered data --#

    dat <- get(as.character(info.cond$Filename[j]))[,c("channel", "cluster_id", "within_session_time_ms")]

    ConditionNumber <- info.cond$ConditionNumber[j]
    analyzed.time <- info.cond$time.analyzed[j]

    shortname <- info.cond$ShortFilename[j]
    start_TW <- info.cond$start_TW[j]
    end_TW <- info.cond$end_TW[j]

    expgrp <- guideline$ExperimentalGroup[j]
    expcond <- guideline$ExperimentalCondition[j]
    TeX <- info.cond$TeX[j]

    if (nrow(dat) > 0) {

      dat <- dat[ order(dat$channel, dat$cluster_id, dat$within_session_time_ms), ]

      # Necessary for performing cluster-level detection of bursts rather than channel-level detection of bursts

      dat$channel.clus <- factor(paste(dat$channel, dat$cluster_id, sep = "_"))

      spike.order <- unlist( tapply(dat$within_session_time_ms, list(dat$channel, dat$cluster_id), rank) )
      isi.ms <- unlist( tapply(dat$within_session_time_ms, list(dat$channel, dat$cluster_id), MEASpikeR:::diff_isi) )
      dat <- data.frame(dat, spike.order, isi.ms)

      if( burst.detection.method == "MI" ) {

        ls.burst <- lapply(unique(dat$channel.clus),
                           function(i) MEASpikeR:::detect_burst_mi(dat$isi.ms[dat$channel.clus == i],
                                                       min_spike_in_burst,
                                                       max_ISI_start_burst,
                                                       max_ISI_end_burst,
                                                       min_IBI,
                                                       min_burst_duration))

      } # end_if_MI

      if( burst.detection.method == "chen") {

        ls.burst <- lapply(unique(dat$channel.clus),
                           function(i) MEASpikeR:::detect_burst_chen(dat$isi.ms[dat$channel.clus == i],
                                                         min_spike_in_burst))

      } # end_if_chen

      dat <- data.frame(dat, burst = as.vector(unlist(ls.burst)))

      dat$burst <- factor(dat$burst)
      dat$channel <- factor(dat$channel)
      dat$burst <- factor(dat$burst,
                          levels = levels(dat$burst)[order(nchar(levels(dat$burst)), levels(dat$burst))] )

    } # end_if_not_empty_dat

    # Only keep channels with bursts

    if( nrow(dat[ !(is.na(dat$burst)), ]) > 0 ) { # at least one burst found across analyzed electrodes

      spike.in.burst <- dat[, c("channel", "cluster_id", "burst")] %>%
        stats::na.omit() %>%
        dplyr::group_by(channel, cluster_id, burst) %>%
        dplyr::summarize(n.spike.in.burst = dplyr::n(), .groups = 'drop')

      burst.duration <- with(dat[ !(is.na(dat$burst)), ],
                             aggregate( within_session_time_ms, list(channel, cluster_id, burst), function(x) diff(range(x)) ))
      colnames(burst.duration) <- c("channel", "cluster_id", "burst", "burst.duration")

      mean.isi.within.burst <- with(dat[ !(is.na(dat$burst)), ],
                                    aggregate( isi.ms, list(channel, cluster_id, burst), function(x) mean(x[-1]) ))
      colnames(mean.isi.within.burst) <- c("channel", "cluster_id", "burst", "mean.isi.within.burst")

      burst.start.time <- with(dat[ !(is.na(dat$burst)), ],
                               aggregate( within_session_time_ms, list(channel, cluster_id, burst), function(x) min(x) ))
      colnames(burst.start.time) <- c("channel", "cluster_id", "burst", "burst.start")

      burst.start.time <- burst.start.time[ order(burst.start.time$channel, burst.start.time$cluster_id, burst.start.time$burst), ]

      ibi.ms <- NA

      if (sum(as.numeric(table(paste0(burst.start.time$channel, burst.start.time$cluster_id)) > 1))) {
        # at least two bursts in a channel/cluster

        ibi.ms <- with(burst.start.time, unlist( tapply(burst.start, list(channel, cluster_id), MEASpikeR:::diff_isi)))

      }

      burst.start.time <- data.frame(burst.start.time, IBI = ibi.ms)

      spike.in.channel <- dat %>% dplyr::group_by(channel, cluster_id) %>% dplyr::summarize(n.spike.in.channel = dplyr::n())

      new.burst.info <- merge(spike.in.burst, burst.duration, by = c("channel", "cluster_id", "burst"))
      new.burst.info <- merge(new.burst.info, mean.isi.within.burst, by = c("channel", "cluster_id", "burst"))
      new.burst.info <- merge(new.burst.info, spike.in.channel, by = c("channel", "cluster_id"))
      new.burst.info <- merge(new.burst.info, burst.start.time, by = c("channel", "cluster_id", "burst"))
      new.burst.info <- data.frame(ConditionNumber, new.burst.info, analyzed.time)

    } # if_at_least_one_burst_detected

    burst.info <- rbind(burst.info, new.burst.info)

  } # end_condition

  if( is.null(burst.info) ) { # 1/ if_zero_burst_over_all_analyzed_conditions

    df.summary1 <- data.frame(matrix(NA, nrow = 0, ncol = 12))

    colnames(df.summary1) <- c("ConditionNumber", "channel", "cluster_id" , "nb.burst", "burst.rate",
                               "burst.rate.min", "burst.mean.duration", "nb.spikes.within", "nb.spikes.outside", "spike.freq.in.burst",
                               "mean.isi.within.burst", "IBI.mean")

    df.summary2 <- data.frame(matrix(0, nrow = length(info.cond$ConditionNumber), ncol = 10))

    colnames(df.summary2) <- c("ConditionNumber", "nb.burst", "burst.rate", "burst.rate.min", "burst.mean.duration",
                               "nb.spikes.within", "nb.spikes.outside", "spike.freq.in.burst", "mean.isi.within.burst", "IBI.mean")

    df.summary2$ConditionNumber <- info.cond$ConditionNumber

  } # end_if_zero_burst_over_all_analyzed_conditions

  if( !(is.null(burst.info)) ) { # 2/ if_not_null_info.burst

    #-----------------------------------------------#

    #-- Table 1. burst.info: one line = one burst --#

    #-----------------------------------------------#

    burst.info$spike.freq.burst <- burst.info$n.spike.in.burst/(burst.info$burst.duration/1000)

    #------------------------------------------------------------------------------------------#

    #-- Table 2. df.summary1: 1 line = 1 channel or 1 line = 1 cluster_id if cluster is TRUE --#

    #------------------------------------------------------------------------------------------#

    df.summary1 <- burst.info %>%
      dplyr::group_by(ConditionNumber, channel, cluster_id) %>%
      dplyr::summarise(
        nb.burst = length(burst),
        burst.rate = length(burst)/analyzed.time[1],
        burst.rate.min = length(burst)/analyzed.time[1]*60,
        burst.mean.duration = mean(burst.duration),
        nb.spikes.within = sum(n.spike.in.burst),
        nb.spikes.outside = n.spike.in.channel[1]-sum(n.spike.in.burst),
        spike.freq.in.burst = mean(spike.freq.burst),
        mean.isi.within.burst = mean(mean.isi.within.burst),
        IBI.mean = round(mean(IBI, na.rm = TRUE))
      )

    #------------------------------------------------#

    #-- Table 3. df.summary2: 1 line = 1 condition --#

    #------------------------------------------------#

    # Add lines of zeros for each of the condition without bursts

    df.summary2 <- df.summary1 %>%
      dplyr::group_by(ConditionNumber) %>%
      dplyr::summarise(
        nb.burst = sum(nb.burst),
        burst.rate = sum(nb.burst)/analyzed.time[1],
        burst.rate.min = sum(nb.burst)/analyzed.time[1]*60,
        burst.mean.duration = mean(burst.mean.duration),
        nb.spikes.within = sum(nb.spikes.within),
        nb.spikes.outside = sum(nb.spikes.outside),
        spike.freq.in.burst = mean(spike.freq.in.burst),
        mean.isi.within.burst = mean(mean.isi.within.burst),
        IBI.mean = mean(IBI.mean, na.rm = TRUE)
      )

    # Complete the conditions without bursts by zero lines

    ix <- setdiff(info.cond$ConditionNumber, df.summary2$ConditionNumber)

    if( length(ix) ) {

      df.summary2 <- merge(df.summary2, info.cond[,"ConditionNumber", drop = FALSE],
                           by = "ConditionNumber", all = TRUE)
      df.summary2[ix,][is.na(df.summary2[ix,])] <- 0

    }

  } # end_if_not_null_info.burst

  df.summary1 <- df.summary1 %>% dplyr::mutate_at(dplyr::vars(burst.mean.duration, mean.isi.within.burst), list(~ round(., 1)))
  df.summary1 <- df.summary1 %>% dplyr::mutate_at(dplyr::vars(spike.freq.in.burst), list(~ round(., 3)))
  df.summary1 <- df.summary1 %>% dplyr::mutate_at(dplyr::vars(burst.rate, burst.rate.min), list(~ round(., 4)))
  df.summary2 <- df.summary2 %>% dplyr::mutate_at(dplyr::vars(burst.mean.duration, mean.isi.within.burst), list(~ round(., 1)))
  df.summary2 <- df.summary2 %>% dplyr::mutate_at(dplyr::vars(spike.freq.in.burst), list(~ round(., 3)))
  df.summary2 <- df.summary2 %>% dplyr::mutate_at(dplyr::vars(burst.rate, burst.rate.min), list(~ round(., 4)))

  df.summary2 <- merge(df.summary2, info.cond[,c("ConditionNumber", "ShortFilename", "record_duration", "TW", "TeX", "time.analyzed")],
                       by = "ConditionNumber")

  df.summary2 <- merge(df.summary2, guideline[,c("ConditionNumber", "ExperimentalCondition", "ExperimentalGroup")],
                       by = "ConditionNumber")

  df.summary2 <- df.summary2[, c("ConditionNumber", "ShortFilename", "record_duration",
                                 "TW", "TeX", "time.analyzed", "ExperimentalGroup", "ExperimentalCondition",
                                 "nb.burst", "burst.rate", "burst.rate.min", "burst.mean.duration",
                                 "nb.spikes.within", "nb.spikes.outside", "spike.freq.in.burst", "mean.isi.within.burst", "IBI.mean")]

  x <- list(
    Burst = burst.info,
    Channel = df.summary1,
    Condition = df.summary2,
    Guideline = guideline
  )

  outfile_name <- paste0(paste("/Burst_Analysis_outfile", Sys.time(), sep = "_"),"s")
  outfile_name <- gsub(" ", "_", outfile_name)
  ix <- unlist(gregexpr("\\:", outfile_name))
  substr(outfile_name, ix[1], ix[1]) <- "h"
  substr(outfile_name, ix[2], ix[2]) <- "m"

  outfile_name <- paste0(outfile_name, "_", guideline$InformationFolderName[1], ".xlsx")

  writexl::write_xlsx(
    x,
    path = paste(getwd(), outfile_name, sep = "/"),
    col_names = TRUE,
    format_headers = TRUE,
    use_zip64 = FALSE
  )

} # FUNCTION END_MEA_6_BURST_ANALYSIS
