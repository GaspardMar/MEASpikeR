#' Spike Waveform
#'
#' Display of overlapped events for each electrode. In the case of spike sorting,
#' display of colored events according to their assignment to a cluster
#' @param object Object of class MEASpikeR generated by the \code{dataset_filtering} function
#' @param filt.data.path Path to "MEA_DATAFILTERED.Rdat" file generated
#' by the \code{dataset_filtering} function
#' @param output_directory Character specifying the directory where you want to save the output folder
#' @param spike_col Character specifying the color parameter for spikes
#' in case spike sorting is FALSE (cluster_id = "none"), (by default "forestgreen")
#' @param scale Character specifying the scale (µV) for the y-axis ("free"/"fixed"),
#' (by default "free")
#' @param mean_trace Boolean, if TRUE the average curve is plotted (by default TRUE)
#' @param col_mean_trace Character specifying the color of the average curve (by default "black")
#' @param color_viridis Boolean, if TRUE the viridis color palette is used
#' for clusters (by default FALSE)
#' @param format.save Character specifying the format in which you want to save the graphics ("both",
#' "one_page" or "several_pages"). if the value is "one_page",  it will display all the graphics for a condition on the
#' same page in a table with 8 rows and 8 columns and save them in '.png' format.
#' If the value is "several_pages",
#' it will diplay every graphics in a ".pdf" document with 12 graphics per page.
#' if the value is "both", it will perform both methods.
#'
#' @return A PDF file and/or an image with the overlapped spike display/plot for
#' each channel is generated for each condition. All files are located in a folder
#' named ‘outfile_waveform’ with the date and time as a prefix. In the PDF files,
#' there are 12 graphics per page, and images represent an 8x8 matrix of graphics.
#' Excluded channels are represented by a cross, and channels with no data are represented by a blank.
#' @export
#' @author François-Xavier Lejeune, Gaspard Martet, Carine Dalle
#' @references  Dalle C., Martet G., Kaddouri Y., Rebola N., Whitmarsh S., Lejeune FX.(2023). **_MEASpikeR_: a new package
#' for spike analysis and visualization of _in vitro_ MEA data**.
#'
#' @examples \dontrun{
#' out.MEA <- MEASpikeR::dataset_filtering(data.path = "C:/Users/prenom.nom/Documents/data",
#' guideline_name_file = "MEA_Spikes_ANA_R_guideline",
#' save.rDATA = TRUE)
#'
#' # if you want to work with the MEASpikeR object
#' MEASpikeR::spike_waveform(
#' object = out.MEA,
#' output_directory = "C:/Users/prenom.nom/Documents"
#' )
#'
#' # if you want to work with the saved Rdat file
#' MEASpikeR::spike_waveform(
#' filt.data.path = "C:/Users/prenom.nom/Documents/data/MEA_DATAFILTERED.Rdat",
#' output_directory = "C:/Users/prenom.nom/Documents"
#' )}
spike_waveform <- function(
    object = NA,
    filt.data.path = NA,
    output_directory = NA,
    spike_col = "forestgreen",
    scale = "free",
    mean_trace = TRUE,
    col_mean_trace = "black",
    color_viridis = FALSE,
    format.save = "both"
) {

  if ( all(!(is.na(object))) & class(object) == "MEASpikeR") {

    attach(object)

  } else {

    if (!(is.na(filt.data.path))) {

      load(filt.data.path)

    } else {

      stop("arguments object and filt.data.path are missing, with no default.")

    } }

  # working directory

  if(!is.na(output_directory)) {setwd(output_directory)}

  else {stop("argument 'output_directory' is missing with no default")}

  # Create output directory in the working directory

  systime <- Sys.time()
  systime <- paste0(systime, "s")
  systime <- gsub(" ", "_", systime)
  ix <- unlist(gregexpr("\\:", systime))
  substr(systime, ix[1], ix[1]) <- "h"
  substr(systime, ix[2], ix[2]) <- "m"

  output.dir <- paste("outfile_waveform", systime, scale, sep = "_")

  if (!(is.na(guideline$InformationFolderName[1]))) {

    output.dir <- paste0(output.dir, "_", guideline$InformationFolderName[1])

  } else {

    output.dir <- paste0(output.dir, "_", "na")
  }

  if (MinFR > 0) { output.dir <- paste0(output.dir, "_MinFR", MinFR) }

  dir.create(output.dir)

  # Set colors for plots

  colclus <- c("#F8766D", "#00BFC4", "#00BA38","#C77CFF","#A3A500","#FB61D7")
  if (color_viridis) colclus <- viridis::viridis_pal()(6)
  names(colclus) <- as.character(1:6)

  mycol <- c(spike_col, colclus, "grey")
  names(mycol) <- c("none", names(colclus), "99")

  #-- Main --#

  for (i in 1:nb.condition) {

    cat("### condition =", i, "\n")

    # Retrieve filtered dataspike + output filename and title name

    dat <- get(as.character(info.cond$Filename[i]))
    dat <- data.frame(spike_id = factor(rownames(dat)), dat)

    start_TW <- guideline$TimeLimitStart[i]
    end_TW <- guideline$TimeLimitEnd[i]

    cond.nb <- guideline$ConditionNumber[i]
    expgrp <- guideline$ExperimentalGroup[i]
    expcond <- guideline$ExperimentalCondition[i]
    TeX <- info.cond$TeX[i]

    spike.sorting  <- info.cond$spike.sorting[i]
    index  <- info.cond$index[i]
    cutoff  <- info.cond$cutoff[i]

    shortname <- info.cond$ShortFilename[i]

    name <- paste0("C_", cond.nb, "_", shortname, "_", expgrp, "_", expcond,
                   "_TW_", start_TW, "-", end_TW, "_TeX_", TeX,
                   "_MinFR_", MinFR)
    if (spike.sorting) name <- paste0(name, "_index_", index, "_", "cutoff", "_", gsub("\\.", "", cutoff))

    name1 <- paste0(name, ".pdf")

    name2 <- paste0(name, ".png")

    if ( info.cond$empty.file[i] ) { # If empty file output void plots

      plot_list <- list()

      nc <- 1

      for (j in 1:nb.electrode) {

        plot_list[[nc]] <- MEASpikeR:::draw_void_plot(j, 1)

        nc <- nc + 1

      }

      glist <- lapply(plot_list, ggplotGrob)

      # Use width = 210, height = 297, units = "mm" for A4 size document

      ggplot2::ggsave(filename = paste0(output.dir, "/", name),
                      gridExtra::marrangeGrob(glist, nrow = 4, ncol = 3, widths = c(1, 1, 1),
                                              layout_matrix = matrix(1:12, 4, 3, TRUE),
                                              bottom = quote(grid::textGrob(paste("\n", "page", g, "of", npages, "\n"),
                                                                            x = .5, hjust = .5)),
                                              top = paste("\n", name, "\n"),
                                              left = "\n", right  = "\n"),
                      width = 210, height = 297, units = "mm")

    } else {  # If not empty file ...

      # spikes_nbr <- as.data.frame(table(dat$channel))
      # colnames(spikes_nbr) <- c("channel","nbr")
      # spikes_nbr <- spikes_nbr[ spikes_nbr$channel %in% ix.ch, ]

      plot_list <- list()

      nc <- 1

      # List of analyzed channels (channels to keep)

      if (length(guideline[ i, "removeChannel" ]) == 0) an.ch <- 1:nb.electrode

      if (length(guideline[ i, "removeChannel" ]) > 0) {

        ix.rm.ch <- unlist(strsplit( guideline[ i, "removeChannel" ], split = ","))
        ix.rm.ch <- as.numeric(ix.rm.ch)
        an.ch <- setdiff(1:nb.electrode, ix.rm.ch)
        an.ch <- sort(unique(an.ch))

      }

      bounds <- range(dat[, grep("_mV", colnames(dat)) ])

      for (j in 1:nb.electrode) {

        cat("# ch =", j, "\n")

        if ( !(j %in% an.ch) ) {

          plot_list[[nc]] <- MEASpikeR:::draw_void_plot(j, 2)

        } else {

          if ( sum(dat$channel == j) == 0 ) {

            plot_list[[nc]] <- MEASpikeR:::draw_void_plot(j, 1)

          } else {

            tmp <- dat[ dat$channel == j, ]
            channel.label <- paste0("channel ", names(table(tmp$channel)), ", n=", table(tmp$channel))

            ldat <- reshape2::melt(data = tmp[ tmp$channel == j, ],
                                   id.vars = c("spike_id", "channel", "time_of_day", "within_session_time", "within_session_time_ms",
                                               "within_trace_time_ms", "cluster_id", "trace_num", "pre_ms", "post_ms"))

            levels(ldat$variable) <- c(0:70)/20-1
            ldat$time <- as.numeric(as.character(ldat$variable))

            p <- ggplot2::ggplot(data = ldat) +
              ggplot2::geom_line(ggplot2::aes(x = time, y = value, group = spike_id, color = factor(cluster_id)), size = .1) +
              ggplot2::scale_colour_manual(values = mycol) +
              ggplot2::scale_x_continuous(breaks = seq(-1, 2.5, .5), limits = c(-1, 2.5)) +
              ggplot2::theme_bw() +
              ggplot2::theme(
                plot.title = ggplot2::element_text(size = 7, hjust = 0.5),
                axis.text = ggplot2::element_text(size = 7, color = "black"),
                axis.title = ggplot2::element_text(size = 7, color = "black"),
                legend.position = "none",
                panel.grid.major.y = ggplot2::element_blank(),
                panel.grid.minor.y = ggplot2::element_blank(),
                panel.grid.major.x = ggplot2::element_line(color = "gray92", size = .1),
                panel.grid.minor.x = ggplot2::element_line(color = "gray95", size = .1),
                panel.border = ggplot2::element_rect(colour = "black", fill = NA, linewidth = .4),
                axis.ticks = ggplot2::element_line(colour = "gray10", size = .3),
                axis.ticks.length = ggplot2::unit(.15, "cm"),
                axis.line = ggplot2::element_line(colour = "black", size = .4)
              ) +
              ggplot2::ggtitle(channel.label) +
              ggplot2::labs(x = "Time (ms)",
                            y = paste0("Amplitude (", paste0("\u00b5","V"),")"))

            if (mean_trace == TRUE) {

              p <- p + ggplot2::stat_summary(ggplot2::aes(x = time, y = value, group = cluster_id),
                                             color = col_mean_trace,
                                             fun = mean, geom = "line")

            }

            if (scale == "fixed") {

              p <- p + ggplot2::scale_y_continuous(limits = bounds)

            }

            plot_list[[nc]] <- p

          }

        }

        nc <- nc + 1

      } # End if_else_else

      #-- Save all plots in a pdf file (8 plots per page) --#

      glist <- lapply(plot_list, ggplotGrob)

      # Use width = 210, height = 297, units = "mm" for A4 size document
      #p_final <- cowplot::plot_grid(plotlist = plot_list, ncol = 8, nrow = 8)


      g <- ggpubr::ggarrange(plotlist = plot_list, ncol = 8, nrow = 8, labels = name)

      title <- grid::textGrob(paste("\n", name, "\n"), gp = grid::gpar(cex = .7))

      g <- ggpubr::annotate_figure(g, top = ggpubr::text_grob(name, size = 14, color = "black", family = "Arial"))

      if (format.save %in% c("both", "one_page")){

        #print(paste0(output.dir, "/", name2))

        ggplot2::ggsave(filename = paste0(output.dir, "/", name2), plot = g, width = 400, height = 400, dpi = 300,
                        units = "mm", bg = "white")

      }

      if (format.save %in% c("both", "several_pages")){
       #print(paste0(output.dir, "/", name1))

        ggplot2::ggsave(filename = paste0(output.dir, "/", name1),
                        gridExtra::marrangeGrob(glist, nrow = 4, ncol = 3, widths = c(1, 1, 1),
                                                layout_matrix = matrix(1:12, 4, 3, TRUE),
                                                bottom = quote(grid::textGrob(paste("\n", "page", g, "of", npages, "\n"),
                                                                              x = .5, hjust = .5)),
                                                top = title,
                                                left = "\n", right  = "\n"),
                        width = 210, height = 297, units = "mm")}



    } # End If not empty file

  } # End_For_Conditions

  guideline.filename <- paste("MEA_Spike_ANA_R_guideline", systime, sep = "_")

  openxlsx::write.xlsx(guideline, paste0(output.dir, "/", guideline.filename, ".xlsx"))

}
