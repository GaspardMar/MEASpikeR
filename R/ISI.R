#' ISI Histogram
#'
#' Generate ISI histogram pdf files
#'
#' @param object Object of class MEASpikeR generated by the \code{dataset_filtering} function
#' @param filt.data.path Path to the ".Rdat" file generated
#' by the \code{dataset_filtering} function
#' @param output_directory Character specifying the directory where we want to save the output folder
#' @param col_hist Character specifying the color of the histogram (by default "darkgreen")
#' @param bin.width Number, parameter of the histogram (by default 50)
#' @param interval.max Number, parameter of the histogram (by default 300)
#' @param format.save Character specifying the format in which you want to save the graphics ("both",
#' "one_page" or "several_pages"). if the value is "one_page",  it will display all the graphics for a condition on the
#' same page in a table with 8 rows and 8 columns and save them in '.png' format.
#' If the value is "several_pages",
#' it will diplay every graphics in a ".pdf" document with 12 graphics per page.
#' if the value is "both", it will perform both methods.
#'
#' @return A PDF file and/or an image with the ISI histogram for
#' each channel is generated for each condition. All files are located in a folder
#' named ‘ISIh_outfiles’ with the date and time as a prefix. In the PDF files,
#' there are 12 graphics per page, and images represent an 8x8 matrix of graphics.
#' Excluded channels are represented by a cross, and channels with no data are represented by a blank.
#' @export
#' @author François-Xavier Lejeune, Gaspard Martet, Carine Dalle
#' @references  Dalle C., Martet G., Kaddouri Y., Rebola N., Whitmarsh S., Lejeune FX.(2023). **_MEASpikeR_: a new package
#' for spike analysis and visualization of _in vitro_ MEA data**.
#'
#' @examples \dontrun{
#' out.MEA <- MEASpikeR::dataset_filtering(data.path = "C:/Users/prenom.nom/Documents/data",
#' guideline_name_file = "MEA_Spikes_ANA_R_guideline",
#' save.rDATA = TRUE)
#'
#' # if you want to work with the MEASpikeR object
#' MEASpikeR::ISI(
#' object = out.MEA,
#' output_directory = "C:/Users/prenom.nom/Documents"
#' )
#'
#' # if you want to work with the saved Rdat file
#' MEASpikeR::ISI(
#' filt.data.path = "C:/Users/prenom.nom/Documents/data/MEA_DATA2ANALYZE.Rdat",
#' output_directory = "C:/Users/prenom.nom/Documents"
#' )
#' }
ISI <- function(
    object = NA,
    filt.data.path = NA,
    output_directory = NA,
    col_hist = "darkgreen",
    bin.width = 50,
    interval.max = 300,
    format.save = "both"
) {

  if ( all(!(is.na(object))) & class(object) == "MEASpikeR") {

    attach(object)

  } else {

    if (!(is.na(filt.data.path))) {

      load(filt.data.path)

    } else {

      stop("arguments object and filt.data.path are missing, with no default.")

    } }

  # working directory

  if(!is.na(output_directory)) {setwd(output_directory)}

  else {stop("argument 'output_directory' is missing with no default")}

  # Create output directory in the working directory

  systime <- Sys.time()
  systime <- paste0(systime, "s")
  systime <- gsub(" ", "_", systime)
  ix <- unlist(gregexpr("\\:", systime))
  substr(systime, ix[1], ix[1]) <- "h"
  substr(systime, ix[2], ix[2]) <- "m"

  output.dir <- paste("ISIh_outfiles", systime, sep = "_")

  if (!(is.na(guideline$InformationFolderName[1]))) {

    output.dir <- paste0(output.dir, "_", guideline$InformationFolderName[1])

  } else {

    output.dir <- paste0(output.dir, "_", "na")

  }

  dir.create(output.dir)

  # loop over the conditions of the guideline file

  for (j in 1:nb.condition) {

    cat("### condition =", j, "\n")

    #-- Import filtered data --#

    dat <- get(as.character(info.cond$Filename[j]))

    dat <- dat[,
               c("channel", "time_of_day",
                 "within_session_time", "within_session_time_ms",
                 "within_trace_time_ms")]

    shortname <- info.cond$ShortFilename[j]
    start_TW <- info.cond$start_TW[j]
    end_TW <- info.cond$end_TW[j]

    cond.nb <- guideline$ConditionNumber[j]
    expgrp <- guideline$ExperimentalGroup[j]
    expcond <- guideline$ExperimentalCondition[j]
    TeX <- info.cond$TeX[j]

    MinFR <- info.cond$MinFR[j]

    # Create name for the pdf or png output file

    name <- paste0("C_", cond.nb, "_",shortname, "_", expgrp, "_", expcond,
                   "_TW_", start_TW, "-", end_TW, "_TeX_", TeX,
                   "_MinFR_", MinFR)

    output.filename <- paste0(name, ".pdf")

    output.filename2 <- paste0(name, ".png")

    if ( info.cond$empty.file[j] ) { # If empty file output void plots

      plot_list <- list()

      nc <- 1

      for (i in 1:nb.electrode) {

        plot_list[[nc]] <- MEASpikeR:::draw_void_plot_2(i, interval.max, type = 1)

        nc <- nc + 1

      } # end_for_channel

      glist <- lapply(plot_list, ggplotGrob)

      # Use width = 210, height = 297, units = "mm" for A4 size document

      ggplot2::ggsave(filename = paste0(output.dir, "/", output.filename),
                      gridExtra::marrangeGrob(glist, nrow = 4, ncol = 3, widths = c(1, 1, 1),
                                              layout_matrix = matrix(1:12, 4, 3, TRUE),
                                              bottom = quote(grid::textGrob(paste("\n", "page", g, "of", npages, "\n"), x = .5, hjust = .5)),
                                              top = paste("\n", shortname, "\n"),
                                              left = "\n", right  = "\n"),
                      width = 210, height = 297, units = "mm")

    } # end_empty_file

    record_duration <- info.cond$record_duration[j]
    true_end <- info.cond$true_end[j]
    time.analyzed <- info.cond$time.analyzed[j]

    if (nrow(dat) > 0) { # if_not_empty_dataset

      dat <- dat[order(dat$channel, dat$within_session_time_ms),]
      spike.order <- unlist( tapply(dat$within_session_time_ms, list(dat$channel), rank) )
      isi.ms <- unlist( tapply(dat$within_session_time_ms, list(dat$channel), MEASpikeR:::diff_isi) )
      dat <- data.frame(dat, spike.order, isi.ms)

      plot_list <- list()

      nc <- 1

      # List of analyzed channels (channels to keep)

      if (length(guideline[ j, "removeChannel" ]) == 0) an.ch <- 1:nb.electrode

      if (length(guideline[ j, "removeChannel" ]) > 0) {

        ix.rm.ch <- unlist(strsplit( guideline[ j, "removeChannel" ], split = ","))
        ix.rm.ch <- as.numeric(ix.rm.ch)
        an.ch <- setdiff(1:nb.electrode, ix.rm.ch)
        an.ch <- sort(unique(an.ch))

      }

      for (i in 1:nb.electrode) {

        cat("# ch =", i, "\n")

        if ( !(i %in% an.ch) ) {

          plot_list[[nc]] <- MEASpikeR:::draw_void_plot_2(i, interval.max, type = 2)

        } else { # analyzed channel

          if ( sum(dat$channel == i) == 0 ) { # no spike in channel

            plot_list[[nc]] <- MEASpikeR:::draw_void_plot_2(i, interval.max, type = 1)

          } else { # if spikes in channel

            tmp <- dat[ dat$channel == i & dat$isi.ms <= interval.max & !(is.na(dat$isi.ms)),]

            if (nrow(tmp) == 0) {

              p <- MEASpikeR:::draw_void_plot_2(i, 300, type = 1)

            } else {

              p <- ggplot2::ggplot(data = tmp, ggplot2::aes(x = isi.ms)) +
                ggplot2::geom_histogram(
                  breaks = seq(0, interval.max, by = bin.width),
                  # bins = round(interval.max/bin.width),
                  fill = col_hist) +
                ggplot2::scale_x_continuous(breaks = seq(0, 1000, 50), minor_breaks = seq(0, 1000, 10),
                                            limits = c(-1, interval.max+1), expand = c(0,0)) +
                ggplot2::scale_y_continuous(expand = c(0,0)) +
                ggplot2::theme_bw() +
                ggplot2::theme(
                  plot.title = ggplot2::element_text(size = 7, hjust = 0.5),
                  axis.text = ggplot2::element_text(size = 7, color = "black"),
                  axis.title = ggplot2::element_text(size = 7, color = "black"),
                  panel.grid.major  = ggplot2::element_line(color = "gray92", size = .1),
                  panel.grid.minor = ggplot2::element_line(color = "gray95", size = .1),
                  panel.background = ggplot2::element_blank(),
                  panel.border = ggplot2::element_rect(colour = "black", fill = NA, size = .4),
                  axis.ticks = ggplot2::element_line(colour = "gray10", size = .3),
                  axis.ticks.length = ggplot2::unit(.15, "cm"),
                  axis.line = ggplot2::element_line(colour = "black", size = .4)
                ) +
                ggplot2::ggtitle(paste0("channel ", i, ", n=", nrow(tmp)))+
                ggplot2::labs(x = "Interspike (ms)",
                              y = "count")

            }

            plot_list[[nc]] <- p

          } # end_if_spikes_in_channel

          # nc <- nc + 1

        } # end_for_channel

        nc <- nc + 1

      } # end_not_empty_dataset

      #-- Save all plots in a pdf file (8 plots per page) --#

      glist <- lapply(plot_list, ggplotGrob)

      #print(plot_list)

      # Use width = 210, height = 297, units = "mm" for A4 size document

      g <- ggpubr::ggarrange(plotlist = plot_list, ncol = 8, nrow = 8, labels = name)

      g <- ggpubr::annotate_figure(g, top = ggpubr::text_grob(name, size = 14, color = "black", family = "Arial"))

      if (format.save %in% c("both", "one_page")){

        ggplot2::ggsave(filename = paste0(output.dir, "/", output.filename2), plot = g, width = 400, height = 400, dpi = 300,
                        units = "mm", bg = "white")

      }

      if (format.save %in% c("both", "several_pages")){

      ggplot2::ggsave(filename = paste0(output.dir, "/", output.filename),
                      gridExtra::marrangeGrob(glist, nrow = 4, ncol = 3, widths = c(1, 1, 1),
                                              layout_matrix = matrix(1:12, 4, 3, TRUE),
                                              bottom = quote(grid::textGrob(paste("\n", "page", g, "of", npages, "\n"), x = .5, hjust = .5)),
                                              top = paste("\n", shortname, "\n"),
                                              left = "\n", right  = "\n"),
                      width = 210, height = 297, units = "mm")}


    } # end_not_empty_file

  } # end_for_condition

  guideline.filename <- paste("MEA_Spike_ANA_R_guideline", systime, sep = "_")

  openxlsx::write.xlsx(guideline, paste0(output.dir, "/", guideline.filename, ".xlsx"))

}
